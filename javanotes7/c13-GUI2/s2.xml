<?xml version="1.0" encoding="UTF-8"?>


<section id="GUI2.2" title="Fancier Graphics">

<p><start><big>T</big>he graphics commands</start> provided by the <classname>Graphics</classname>
class are sufficient for many purposes.  However, recent versions of Java provide a much
larger and richer graphical toolbox in the form of the class <code>java.awt.Graphics2D</code>.
I mentioned <classname>Graphics2D</classname> in <localref href="GUI1.3.5"/> and promised
to discuss it further in this chapter.  You have already seen a few of the ideas that
are covered in this section, at least briefly, but I cover them in more detail here.</p>
   
<p><classname>Graphics2D</classname> is a subclass of <classname>Graphics</classname>, so
all of the graphics commands that you already know can be used with a <classname>Graphics2D</classname>
object.  In fact, when you obtain a <classname>Graphics</classname> context for drawing
on a Swing component, the graphics object is
actually of type <classname>Graphics2D</classname> and can be type-cast to gain access to
the advanced <classname>Graphics2D</classname> graphics commands.  Furthermore, <classname>BufferedImage</classname>
has the instance method, <code>createGraphics()</code>, that returns a graphics context of
type <classname>Graphics2D</classname>. As mentioned in <localref href="GUI1.3.5"/>,
to use <classname>Graphics2D</classname> commands in the <code>paintComponent()</code> method
of a Swing component, you can use code of the form:</p>

<pre>
public void paintComponent(Graphics g) {
   super.paintComponent(g);
   Graphics g2 = (Graphics2D)g;
      .
      .   // Draw to the component using g2 (and g).
      .
}</pre>
   
<np>Note that when you do this, <code>g</code> and <code>g2</code> are just two variables
that refer to the same object, so they both draw to the same drawing surface and have the 
same state.  When properties of <code>g2</code>, such as
drawing color, are changed, the changes also apply to <code>g</code>.  By saying</np>
   
<pre>Graphics2D g2 = (Graphics2D)<newcode>g.create()</newcode>;</pre>
   
<np>you can obtain a newly created graphics context.  The object created by <code>g.create()</code>
is a graphics context that draws to the same drawing surface as <code>g</code> and that initially
has all the same properties as <code>g</code>.  However, it is a separate object, so that
changing properties in <code>g2</code> has no effect on <code>g</code>.  This can be useful
if you want to keep an unmodified copy of the original graphics context around for some
drawing operations.  (In this case, it is good practice to call <code>g2.dispose()</code>
to dispose of the new graphics context when you are finished using it.)</np>
   
<subsection id="GUI2.2.1" title="Measuring Text">
   
<p>Although this section is mostly about <classname>Graphics2D</classname>, we start
with a topic that has nothing to do with it.</p>

<p>Often, when drawing a string, it's important to know how big the image of
the string will be. For example, you need this information if you want to center a string in
a component.  Or if you want to know how much space to leave between two lines of
text, when you draw them one above the other. Or if the user is typing the
string and you want to position a cursor at the end of the string. In Java,
questions about the size of a string can be answered by an object belonging to the
standard class <code>java.awt.FontMetrics</code>.</p>

<p>There are several lengths associated with any given font. Some of them are
shown in this illustration:</p>

<img src="measuring-strings.png" alt="Measuring Strings, showing ascent, descent, leading, and lineheight" 
    width="584" height="131" tex="measuring-strings.eps" texscale="0.6"/>
   
<p>The dashed <web>red </web>lines in the illustration are the <newword>baselines</newword> 
of the two lines of text.   The baseline of a string is the line on which the bases
of the characters rest.  The suggested distance
between two baselines, for single-spaced text, is known as the 
<newword>lineheight</newword> of the font. The <newword>ascent</newword> 
is the distance that tall characters can rise above the
baseline, and the <newword>descent</newword> is the distance that
tails like the one on the letter "g" can descend below the baseline. The ascent
and descent do not add up to the lineheight, because there should be some extra
space between the tops of characters in one line and the tails of characters on
the line above. The extra space is called <newword>leading</newword>.
(The term comes from the time when lead blocks were used for printing. Characters
were formed on blocks of lead that were lined up to make up the text of a page, 
covered with ink, and pressed onto paper to print the page. 
Extra, blank "leading" was used to separate the lines of characters.)
All these quantities can be determined by calling instance methods in a
<classname>FontMetrics</classname> object. There are also methods for determining the width
of a character and the total width of a string of characters.</p>

<p>Recall that a font in Java is represented by the class <classname>Font</classname>.
A <classname>FontMetrics</classname> object is associated with a given font and
is used to measure characters and strings in that font.
If <code>font</code> is of type <classname>Font</classname>
and <code>g</code> is a graphics context, you can get a
<classname>FontMetrics</classname> object for the font  by calling
<code>g.getFontMetrics(font)</code>.  If <code>fm</code> is the variable that refers to the
<classname>FontMetrics</classname> object, then the ascent, descent, leading, and lineheight
of the font can be obtained by calling <code>fm.getAscent()</code>,
<code>fm.getDescent()</code>, <code>fm.getLeading()</code>, and
<code>fm.getHeight()</code>. If <code>ch</code> is a character, then
<code>fm.charWidth(ch)</code> is the width of the character when it is drawn in
that font. If <code>str</code> is a string, then <code>fm.stringWidth(str)</code> is
the width of the string when drawn in that font. 
For example, here is a <code>paintComponent()</code> method that shows the message 
"Hello World" in the exact center of the component:</p>

<pre>public void paintComponent(Graphics g) {
   super.paintComponent(g);
   
   int strWidth, strHeight; // Width and height of the string.
   int centerX, centerY;    // Coordinates of the center of the component.
   int baseX, baseY;        // Coordinates of the baseline of the string.
   int topOfString;         // y-coordinate of the top of the string.
   
   centerX = getWidth() / 2;
   centerY = getHeight() / 2;        
   
   Font font = g.getFont();  // What font will g draw in?
   FontMetrics fm = g.getFontMetrics(font);
   strWidth = fm.stringWidth("Hello World");
   strHeight = fm.getAscent();  // Note: There are no tails on and
                                //   of the chars in the string!  So we
                                //   don't need to account for descent.
 
   baseX = centerX - (strWidth/2);  // Move back from center by half the
                                    //    width of the string.
   
   topOfString = centerY - (strHeight/2);  // Move up from center by half
                                           //   the height of the string.
   
   baseY = topOfString + fm.getAscent();  // Baseline is fm.getAscent() pixels
                                          //   below the top of the string.
    
   g.drawString("Hello World", baseX, baseY); // Draw the string.
}</pre>
   
<np>For the height of
the string in this method, I use <code>fm.getAscent()</code>.  If I were
drawing "Goodbye World" instead of "Hello World," I would have used
<code>fm.getAscent() + fm.getDescent()</code>, where the descent is
added to the height in order to take into account the tail on the
"y" in "Goodbye".  The value of <code>baseX</code> is computed
to be the amount of space between the left edge of the component and
the start of the string. It is obtained by subtracting half the width
of the string from the horizontal center of the component.  This will
center the string horizontally in the component.  The next line computes
the position of the top of the string in the same way.  However, to draw the
string, we need the y-coordinate of the baseline, not the y-coordinate of
the top of the string.  The baseline of the string is below the top of the 
string by an amount equal to the ascent of the font.  </np>
   
<p>There is an example of centering a two-line block of text in the
sample program <sourceref href="TransparencyDemo.java"/>, which is discussed in
the next subsection.</p>
      
</subsection>
   
      
<subsection id="GUI2.2.2" title="Transparency">
   
<p>A color is represented by red, blue, and green components.  In Java's usual representation,
each component is an eight-bit number in the range 0 to 255.  The three color components can
be packed into a 32-bit integer, but that only accounts for 24 bits in the integer.  What
about the other eight bits?  They don't have to be wasted.  They can be used as a fourth
component of the color, the <newword>alpha component</newword>.  The alpha component can
be used in several ways, but it is most commonly associated with <newword>transparency</newword>.
When you draw with a transparent color, it's like laying down a sheet of colored glass. It
doesn't completely obscure the part of the image that is colored over.  Instead, the
background image is <newword>blended</newword> with the transparent color that is
used for drawing&mdash;as if you were looking at the background through colored glass.
This type of drawing is properly referred to as <newword>alpha blending</newword>, and
it is not equivalent to true transparency; nevertheless, most people refer to it as
transparency.</p>
   
<p>The value of the alpha component determines how transparent that color is.  Actually,
the alpha component gives the <newword>opaqueness</newword> of the color.  Opaqueness is
the opposite of transparency.  If something is fully opaque, you can't see through it at all;
if something is almost fully opaque, then it is just a little transparent; and so on.
When the alpha component of a color has the maximum possible value, the color is fully
opaque.  When you draw with a fully opaque color, that color simply replaces the
color of the background over which you draw.  Except for a little example in <localref href="OOP.3.2"/>,
this is the only type of color that we have
used up until now.  If the alpha component of a color is zero, then the color is
perfectly transparent, and drawing with that color has no effect at all.  Intermediate
values of the alpha component give partially opaque colors that will blend with the
background when they are used for drawing.</p>
   
<p>The sample program <sourceref href="TransparencyDemo.java"/> can help you to understand
transparency.  When you run the program you will see a display area containing a triangle,
an oval, a rectangle, and some text.  Sliders at the bottom of the window allow you to control 
the degree of transparency of each shape.  When a slider is moved all the way to the
right, the corresponding shape is fully opaque; all the way to the left, and the shape
is fully transparent.</p>
   
<break/>

<p>Colors with alpha components were introduced in Java along with <classname>Graphics2D</classname>,
but they can be used with ordinary <classname>Graphics</classname> objects as well.
To specify the alpha component of a color, you can create the <classname>Color</classname> object
using one of the following constructors from the <classname>Color</classname> class:</p>
   
<pre>public Color(int red, int green, int blue, int alpha);
   
public Color(float red, float green, float blue, float alpha);</pre>
   
<np>In the first constructor, all the parameters must be integers in the
range 0 to 255.  In the second, the parameters must be in the range
0.0 to 1.0.  For example,</np>
   
<pre>Color transparentRed = new Color( 255, 0, 0, 200 );</pre>
   
<np>makes a slightly transparent red, while</np>
   
<pre>Color tranparentCyan = new Color( 0.0F, 1.0F, 1.0F, 0.5F);</pre>
   
<np>makes a blue-green color that is 50% opaque.  (The advantage of
the constructor that takes parameters of type <ptype>float</ptype> is
that it lets you think in terms of percentages.)  When you create
an ordinary RGB color, as in <code>new&nbsp;Color(255,0,0)</code>,
you just get a fully opaque color.</np>
   
<p>Once you have a transparent color, you can use it in the same way
as any other color.  That is, if you want to use a <classname>Color</classname>
<code>c</code> to draw in a graphics context <code>g</code>, you just
say <code>g.setColor(c)</code>, and subsequent drawing operations
will use that color.  As you can see, transparent colors are very
easy to use.</p>

<break/>
   
<p>A <classname>BufferedImage</classname> with image type <code>BufferedImage.TYPE_INT_ARGB</code>
can use transparency.  The color of each pixel in the image can have its own
alpha component, which tells how transparent that pixel will be when the image is
drawn over some background.  A pixel whose alpha component is zero is perfectly transparent,
and has no effect at all when the image is drawn; in effect, it's not part of the image at all.
It is also possible for pixels to be partly transparent.  When an image is saved to a file,
information about transparency might be lost, depending on the file format.  The PNG
image format supports transparency; JPEG does not.  (If you look at the images of playing
cards that are used in the program <code>HighLowWithImages</code> in
<localref href="GUI2.1.1"/>, you might notice that the tips of the corners of the cards are fully
transparent.  The card images are from a PNG file, <sourceref href="cards.png"/>.)</p>
   
<p>An ARGB <classname>BufferedImage</classname> should be fully transparent when it is 
first created, but if you want to make sure, here is one way of doing so:  
The <classname>Graphics2D</classname>
class has a method <code>setBackground()</code> that can be used to set a background
color for the graphics context, and it has a <code>clearRect()</code> method that
fills a rectangle with the current background color.  To create a fully transparent
image with width <code>w</code> and height <code>h</code>, you can use:</p>

<pre>BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
Graphics2D g2 = image.createGraphics();
g2.setBackground(new Color(0,0,0,0));  // (The R, G, and B values don't matter.)
g2.clearRect(0, 0, w, h);</pre>

<np>(Note that simply drawing with a transparent color will not make pixels in the
image transparent. The alpha component of a <classname>Color</classname> makes
the color transparent when it is used for drawing; it does not change the 
transparency of the pixels that are modified by the drawing operation.)</np>
      
<p>As an example, just for fun, here is a method that will set the cursor of a component
to be a red square with a transparent interior:</p>
   
<pre>private void useRedSquareCursor() {
   BufferedImage image = new BufferedImage(24,24,BufferedImage.TYPE_INT_ARGB);
   Graphics2D g2 = image.createGraphics();
   g2.setBackground(new Color(0,0,0,0));
   g2.clearRect(0, 0, 24, 24);  // (should not be necessary in a new image)
   g2.setColor(Color.RED);
   g2.drawRect(0,0,23,23); // draw a red border of width 3 around the square
   g2.drawRect(1,1,21,21);
   g2.drawRect(2,2,19,19);
   g2.dispose();
   Point hotSpot = new Point(12,12);
   Toolkit tk = Toolkit.getDefaultToolkit();
   Cursor cursor = tk.createCustomCursor(image,hotSpot,"square");
   setCursor(cursor);
}</pre>

</subsection>
   
      
<subsection id="GUI2.2.3" title="Antialiasing">
   
<p>To draw a geometric figure such as a line or circle, you just have to
color the pixels that are part of the figure, right?  Actually, there is
a problem with this.  Pixels are little squares.  Geometric figures, on
the other hand, are made of geometric points that have no size at all.
Think about drawing a circle, and think about a pixel on the boundary
of that circle.  The infinitely thin geometric boundary of the circle
cuts through the pixel.  Part of the pixel lies inside the circle,
part lies outside.  So, when we are filling the circle with color,
do we color that pixel or not?  A possible solution is to color
the pixel if the geometric circle covers 50% or more of the pixel.
Following this procedure, however, leads to a visual defect
known as <newword>aliasing</newword>.  It is visible in images
as a jaggedness or "staircasing" effect along the borders of curved
shapes.  Lines that are not horizontal or vertical also have a jagged,
aliased appearance.  (The term "aliasing" seems to refer to the fact
that many different geometric points map to the same pixel.  If you
think of the real-number coordinates of a geometric point as a "name" for
the pixel that contains that point, then each pixel has many different 
names or "aliases.")</p>
   
<p>It's not possible to build a circle out of squares, but there is
a technique that can eliminate some of the jaggedness of aliased images.  The
technique is called <newword>antialiasing</newword>.  Antialiasing is
based on transparency.  The idea is simple:  If 50% of a pixel is
covered by the geometric figure that you are trying to draw, then
color that pixel with a color that is 50% transparent.  If 25% of the
pixel is covered, use a color that is 75% transparent (25% opaque).
If the entire pixel is covered by the figure, of course, use a color
that is 100% opaque&mdash;antialiasing only affects pixels that are only
partly covered by the geometric shape.</p>
   
<p>In antialiasing, the color that you are drawing
with is blended with the original color of the pixel, and the amount
of blending depends on the fraction of the pixel that is covered by
the geometric shape.  (The fraction is difficult to compute exactly,
so in practice, various methods are used to approximate it.)  Of course, 
you still don't get a picture of the exact geometric shape, but antialiased
images do tend to look better than jagged, aliased images.</p>
   
<p>For an example, look at the picture in the
next subsection.  Antialiasing is used to draw the panels in the second
and third row of the picture, but it is not
used in the top row.  You should note the jagged appearance of the lines 
in the top row.  (By the way, when antialiasing is applied
to a line, the line is treated as a geometric rectangle whose width
is equal to the line width.)</p>

<p>Antialiasing is supported in <classname>Graphics2D</classname>.  By
default, antialiasing is turned off.  If <code>g2</code> is a graphics
context of type <classname>Graphics2D</classname>, you can turn on
antialiasing in <code>g2</code> by saying:</p>
   
<pre>g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                                  RenderingHints.VALUE_ANTIALIAS_ON);</pre>

<np>As you can see, this is only a "hint" that you would like to use
antialiasing, and it is even possible that the hint will be ignored.
However, it is likely that subsequent drawing operations in <code>g2</code>
will be antialiased.  If you want to turn antialiasing off in
<code>g2</code>, you should say:</np>
   
<pre>g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                                  RenderingHints.VALUE_ANTIALIAS_OFF);</pre>
      
</subsection>
   
      
<subsection id="GUI2.2.4" title="Strokes and Paints">
   
<p>When using the <classname>Graphics</classname> class, any line that you
draw will be a solid line that is one pixel thick.  The <classname>Graphics2D</classname>
class makes it possible to draw a much greater variety of lines.  You can draw
lines of any thickness, and you can draw lines that are dotted or dashed instead
of solid.</p>
   
<p>An object of type <classname>Stroke</classname> contains information about how
lines should be drawn, including how thick the line should be and what pattern of
dashes and dots, if any, should be used.  Every <classname>Graphics2D</classname>
has an associated <classname>Stroke</classname> object.  The default <classname>Stroke</classname>
draws a solid line of thickness one.  To get lines with different properties, you
just have to install a different stroke into the graphics context.</p>
   
<p><classname>Stroke</classname> is an <code>interface</code>, not a class.  The class
<classname>BasicStroke</classname>, which implements the <code>Stroke</code> interface,
is the one that is actually used to create stroke objects.  For example, to
create a stroke that draws solid lines with thickness equal to 3, use:</p>
   
<pre>BasicStroke line3 = new BasicStroke(3);</pre>
   
<np>If <code>g2</code> is of type <classname>Graphics2D</classname>, the stroke can be
installed in <code>g2</code> by calling its <code>setStroke()</code> command:</np>

<pre>g2.setStroke(line3)</pre>
   
<np>After calling this method, subsequent drawing operations will use lines that are
three times as wide as the usual thickness.
The thickness of a line can be given by a value of type <ptype>float</ptype>,
not just by an <ptype>int</ptype>.  For example, to use lines of thickness
2.5 in the graphics context <code>g2</code>, you can say:</np>
   
<pre>g2.setStroke( new BasicStroke(2.5F) );</pre>
   
<np>(Fractional widths make more sense if antialiasing is turned on.)</np>
   
<p>When you have a thick line, the question comes up, what to do at the ends
of the line.  If you draw a physical line with a large, round piece of chalk, the
ends of the line will be rounded.  When you draw a line on the computer
screen, should the ends be rounded, or should the line simply be cut off
flat?  With the <classname>BasicStroke</classname> class, the choice is up to you.
Maybe it's time to look at examples.  This illustration
shows fifteen lines, drawn using different <classname>BasicStrokes</classname>.
Lines in the middle row have rounded ends; lines in the other two rows are
simply cut off at their endpoints.  Lines of various thicknesses are shown,
and the bottom row shows dashed lines.  (And, as mentioned above, only the
bottom two rows are antialiased.)</p>

<img src="stroke-demo.png" width="518" height="312" alt="lines drawn with various BasicStrokes"
     tex="stroke-demo.eps" texscale="0.6"/>

<np>This illustration is a screenshot from the sample program <sourceref href="StrokeDemo.java"/>.
In that program, you can click and drag
in any of the small panels, and the lines in all the panels will be redrawn
as you move the mouse.  In addition, if you right-click and drag, then
rectangles will be drawn instead of lines; this shows that strokes are used
for drawing the outlines of shapes and not just for straight lines.
If you look at the corners of the rectangles that are drawn by the program,
you'll see that there are several ways of drawing a corner where two wide
line segments meet.</np>
   
<p>All the options that you want for a <classname>BasicStroke</classname> have
to be specified in the constructor.  Once the stroke object is created, there
is no way to change the options.  There is one constructor that lets you specify
all possible options:</p>
   
<pre>public BasicStroke( float width, int capType, int joinType, float miterlimit,
                                         float[] dashPattern, float dashPhase )</pre>
   
<np>I don't want to cover all the options in detail, but here's some basic
info:</np>
   
<ul>
<li><code>width</code> specifies the thickness of the line</li>
<li><code>capType</code> specifies how the ends of a line are "capped."  The
possible values are <code>BasicStroke.CAP_SQUARE</code>, <code>BasicStroke.CAP_ROUND</code>
and <code>BasicStroke.CAP_BUTT</code>.  These values are used, respectively, in the
first, second, and third rows of the above picture.
The default is <code>BasicStroke.CAP_SQUARE</code>.</li>
<li><code>joinType</code> specifies how two line segments are joined together at
corners.  Possible values are <code>BasicStroke.JOIN_MITER</code>,
<code>BasicStroke.JOIN_ROUND</code>, and <code>BasicStroke.JOIN_BEVEL</code>.
Again, these are used in the three rows of panels in the sample program;
you will only see the effect if you run the program and draw some rectangles.
The default is <code>BasicStroke.JOIN_MITER</code>.</li>
<li><code>miterLimit</code> is used only if the value of <code>joinType</code> is
<code>JOIN_MITER</code>; just use the default value, <code>10.0F</code>.</li>
<li><code>dashPattern</code> is used to specify dotted and dashed lines.  The
values in the array specify lengths in the dot/dash pattern.  The numbers in the
array represent the length of a solid
piece, followed by the length of a transparent piece, followed by the length of
a solid piece, and so on.  At the end of the array, the pattern wraps back to the
beginning of the array.  If you want a solid line, use a different
constructor that has fewer parameters.</li>
<li><code>dashPhase</code> tells the computer where to start in the <code>dashPattern</code>
array, for the first segment of the line.  Use 0 for this parameter in most cases.</li>
</ul>
   
<np>For the third row in the above picture, the
<code>dashPattern</code> is set to <code>new&nbsp;float[]&nbsp;{5,5}</code>.
This means that the lines are drawn starting with a solid segment of length 5,
followed by a transparent section of length 5, and then repeating the same pattern.
A simple dotted line would have thickness 1 and <code>dashPattern</code>
<code>new&nbsp;float[]&nbsp;{1,1}</code>.  A pattern of short and long dashes
could be made by using <code>new&nbsp;float[]&nbsp;{10,4,4,4}</code>.
For more information, see the Java documentation, or try experimenting
with the source code for the sample program.</np>
   
<break/>
   
<p>So now we can draw fancier lines.  But any drawing operation is still
restricted to drawing with a single color.  We can get around that restriction
by using <classname>Paint</classname>.  An object of type <classname>Paint</classname>
is used to assign color to each pixel that is "hit" by a drawing operation.
<classname>Paint</classname> is an <code>interface</code>, and the <classname>Color</classname>
class implements the <classname>Paint</classname> interface.  When a color is used
for painting, it applies the same color to every pixel that is hit.
However, there are other types of paint where the color that is applied to
a pixel depends on the coordinates of that pixel.  Standard Java includes several
classes that define paint with this property: <classname>TexturePaint</classname>
and several types of gradient paint. In a <newword>texture</newword>,
the pixel colors come from an image, which is repeated, if necessary, like a wallpaper pattern
to cover the entire xy-plane. In a <newword>gradient</newword>,
the color that is applied to pixels changes gradually from one color to another
color as you move from point to point.  Java has three types of gradient paints:
<classname>GradientPaint</classname>, <classname>LinearGradientPaint</classname>,
and <classname>RadialGradientPaint</classname>.</p>
   
<p>It will be helpful to look at some examples.  This illustration shows a polygon
filled with two different paints.  The polygon on the left uses a <classname>GradientPaint</classname>
while the one on the right uses a <classname>TexturePaint</classname>.  Note that in this picture, 
the paint is used only for filling
the polygon.  The outline of the polygon is drawn in a plain black color.  However,
<classname>Paint</classname> objects can be used for drawing lines as well as
for filling shapes.  These pictures were made by the sample program
<sourceref href="PaintDemo.java"/>.  In that program, you can select among several
different paints, and you can control certain properties of the paints.</p>

<img src="paint-demo.png" width="570" height="219" alt="two types of paint, gradient fill and texture fill"
      tex="paint-demo.eps" texscale="0.6" bordered="true"/>
 
<np>Basic gradient paints are created using the constructor</np>

<pre>public GradientPaint(float x1, float y1, Color c1,
                             float x2, float y2, Color c2, boolean cyclic)</pre>
   
<np>This constructs a gradient that has color <code>c1</code> at the
point with coordinates <code>(x1,y1)</code> and color <code>c2</code> at the point
<code>(x2,y2)</code>.  As you move along the line between the two points,
the color of the gradient changes from <code>c1</code> to <code>c2</code>;
along lines perpendicular to this line, the color is constant.  The
last parameter, <code>cyclic</code>, tells what happens if you move past the
point <code>(x2,y2)</code> on the line from <code>(x1,y1)</code> to <code>(x2,y2)</code>.
If <code>cyclic</code> is <code>false</code>, the color stops changing and any point beyond
<code>(x2,y2)</code> has color <code>c2</code>.  If <code>cyclic</code> is <code>true</code>,
then the colors continue to change in a cyclic pattern after you move past
<code>(x2,y2)</code>.  (It works the same way if you move past the other
endpoint, <code>(x1,y1)</code>.)  In most cases, you will set <code>cyclic</code>
to <code>true</code>.  Note that you can vary the points <code>(x1,y1)</code>
and <code>(x2,y2)</code> to change the width and direction of the gradient.
For example, to create a cyclic gradient that varies from black to light gray along the line
from <code>(0,0)</code> to <code>(100,100)</code>, use:</np>
   
<pre>new GradientPaint( 0, 0, Color.BLACK, 100, 100, Color.LIGHT_GRAY, true)</pre> 

<np>The other two gradient paint classes, <classname>LinearGradientPaint</classname>
and <classname>RadialGradientPaint</classname>, are more sophisticated.
Linear gradient paints are similar to
<classname>GradientPaint</classname> but can be based on more than two colors.  Radial gradients
color pixels based on their distance from a central point, which produces rings of constant
color instead of lines of constant color.  See the API documentation for details.</np>

<break/>
   
<p>To construct a <classname>TexturePaint</classname>, you need a <classname>BufferedImage</classname>
that contains the image that will be used for the texture.  You also specify a rectangle
in which the image will be drawn.  The image will be scaled, if necessary, to exactly fill
the rectangle.  Outside the specified rectangle, the image will be repeated horizontally
and vertically to fill the plane.  You can vary the size and position of the rectangle
to change the scale of the texture and its positioning on the plane.  Ordinarily, however
the upper left corner of the rectangle is placed at <code>(0,0)</code>, and the size of the rectangle
is the same as the actual size of the image.  The constructor for <classname>TexturePaint</classname>
is defined as</p>
   
<pre>public TexturePaint( BufferedImage textureImage, Rectangle2D anchorRect)</pre>
   
<np>The <classname>Rectangle2D</classname> class is part of the <classname>Graphics2D</classname>
framework and will be discussed at the end of this section.  Often, a call to the
constructor takes the following form, which will show the image at its actual size:</np>
   
<pre>new TexturePaint( image, 
            new Rectangle2D.Double(0,0,image.getWidth(),image.getHeight() )</pre>
   
<p>Once you have a <classname>Paint</classname> object, you can use the
<code>setPaint()</code> method of a <classname>Graphics2D</classname> object
to install the paint in a graphics context.  For example, if <code>g2</code>
is of type <classname>Graphics2D</classname>, then the command</p>

<pre>g2.setPaint( new GradientPaint(0,0,Color.BLUE,100,100,Color.GREEN,true) );</pre>
   
<np>sets up <code>g2</code> to use a gradient paint.  Subsequent drawing operations
with <code>g2</code> will draw using a blue/green gradient.</np>
   
</subsection>
   
      
<subsection id="GUI2.2.5" title="Transforms and Shapes">
   
<p>In the standard drawing coordinates on a component, the upper left corner
of the component has coordinates <code>(0,0)</code>.  Coordinates are integers, and the
coordinates <code>(x,y)</code> refer to the point that is <code>x</code> pixels
over from the left edge of the component and <code>y</code> pixels down from
the top.  With <classname>Graphics2D</classname>, however, you are not
restricted to using these coordinates.  In fact, you can can set up
a <classname>Graphics2D</classname> graphics context to use any system
of coordinates that you like.  You can use this capability to select the
coordinate system that is most appropriate for the things that you want to
draw.  For example, if you are drawing architectural blueprints, you might
use coordinates in which one unit represents an actual distance of one foot.
</p>

<p>Changes to a coordinate system are referred to as <newword>transforms</newword>.
There are three basic types of transform.  A <newword>translate</newword> transform
changes the position of the origin, <code>(0,0)</code>.  A <newword>scale</newword> transform changes
the scale, that is, the unit of distance.  And a <newword>rotation</newword> transform
applies a rotation about some point.  You can make more complex transforms by
combining transforms of the three basic types.  For example, you can apply a
rotation, followed by a scale, followed by a translation, followed by another
rotation.  When you apply several transforms in a row, their effects are cumulative.
It takes a fair amount of study to fully understand complex transforms, and
transforms are a major topic in a course in computer graphics.
I will limit myself here to discussing a few of the most simple cases, just to
give you an idea of what transforms can do.</p>
   
<p>Suppose that <code>g2</code> is of type <classname>Graphics2D</classname>.
Then <code>g2.translate(x,y)</code> moves the origin, <code>(0,0)</code>, to the point <code>(x,y)</code>.
This means that if you use coordinates <code>(0,0)</code> <b>after</b> saying <code>g2.translate(x,y)</code>,
then you are referring to the point that <i>used to be</i> <code>(x,y)</code>, before
the translation was applied.  All other coordinate pairs are moved by the same amount.
For example saying</p>
   
<pre>g.translate(x,y);
g.drawLine( 0, 0, 100, 200 );</pre>
   
<np>draws the same line as</np>
   
<pre>g.drawLine( x, y, 100+x, 200+y );</pre>

<np>In the second case, you are just doing the same translation "by hand."
A translation (like all transforms) affects all subsequent drawing operations.
Instead of thinking in terms of coordinate systems, you might find it clearer
to think of what happens to the objects that are drawn.  After you say
<code>g2.translate(x,y)</code>, any objects that you draw are displaced <code>x</code>
units horizontally  and <code>y</code> units vertically.
Note that the parameters <code>x</code> and <code>y</code> can be real numbers.</np>
   
<p>As an example, perhaps you would prefer to have <code>(0,0)</code> at the center of a
component, instead of at its upper left corner.  To do this, just use the
following command in the <code>paintComponent()</code> method of the  component:</p>
   
<pre>g2.translate( getWidth()/2, getHeight()/2 );</pre>
   
<p>To apply a scale transform to a <classname>Graphics2D</classname> <code>g2</code>,
use <code>g2.scale(s,s)</code>, where <code>s</code> is the real number that specifies
the scaling factor.  If <code>s</code> is greater than 1, everything is magnified
by a factor of <code>s</code>, while if <code>s</code> is between 0 and 1,
everything is shrunk by a factor of <code>s</code>.  The center of scaling is
<code>(0,0)</code>.  That is, the point <code>(0,0)</code> is unaffected by the scaling, and other points
more towards or away from <code>(0,0)</code> by a factor of&nbsp;<code>s</code>.  Again,
it can be clearer to think of the effect on objects that are drawn after a
scale transform is applied.  Those objects will be magnified or shrunk by
a factor of&nbsp;<code>s</code>. Note that scaling affects <b>everything</b>, 
including thickness of lines and size of fonts.  It is possible to use different scale
factors in the horizontal and vertical direction with a command of the form
<code>g2.scale(sx,sy)</code>, although that will distort the shapes of objects.
By the way,  it is even possible to use scale factors that are less than&nbsp;0,
which results in reflections.  For example, after calling <code>g2.scale(-1,1)</code>,
objects will be reflected horizontally through the line <code>x=0</code>.
</p>
   
<p>The third type of basic transform is rotation.  The command <code>g2.rotate(r)</code>
rotates all subsequently drawn objects through an angle of <code>r</code> about the
point <code>(0,0)</code>.  You can rotate instead about the point <code>(x,y)</code>
with the command <code>g2.rotate(r,x,y)</code>.  All the parameters can be real
numbers.  Angles are measured in radians, where &pi; radians are equal to 180 degrees.
To rotate through an angle of <code>d</code> degrees, use</p>

<pre>g2.rotate( d * Math.PI / 180 );</pre>
   
<np>Positive angles are clockwise rotations, while negative angles are
counterclockwise (unless you have applied a negative scale factor,
which reverses the orientation).</np>
   
<p>Rotation is not as common as translation or scaling, but there are a few things
that you can do with it that can't be done any other way.  For example, you can
use it to draw an image "on the slant."  Rotation also makes it possible to draw text 
that is rotated so that its baseline is slanted or even vertical.  To draw the
string "Hello World" with its basepoint at <code>(x,y)</code> and rising at
an angle of 30 degrees, use:</p>
   
<pre>g2.rotate( -30 * Math.PI / 180, x, y );
g2.drawString( "Hello World", x, y );</pre>
   
<np>To draw the message vertically, with the <b>center</b> of its baseline
at the point <code>(x,y)</code>, we can use <classname>FontMetrics</classname>
to measure the string, and say:</np>
   
<pre>FontMetrics fm = g2.getFontMetrics( g2.getFont() );
int baselineLength = fm.stringWidth("Hello World");
g2.rotate( -90 * Math.PI / 180, x, y);
g2.drawString( "Hello World", x - baselineLength/2, y );</pre>

<break/>

<p>The drawing operations in the <classname>Graphics</classname> class use
integer coordinates only.  <classname>Graphics2D</classname> makes it
possible to use real numbers as coordinates.  This becomes particularly important
once you start using transforms, since after you apply a scaling transform, a square of size
one might cover many pixels instead of just a single pixel.  Unfortunately, the
designers of Java couldn't decide whether to use numbers of type <ptype>float</ptype>
or <ptype>double</ptype> as coordinates, and their indecision makes things a
little more complicated than they need to be.  (My guess is that they really
wanted to use <ptype>float</ptype>, since values of type float have enough
accuracy for graphics and are probably used in the underlying graphical computations
of the computer.  However, in Java programming, it's easier to use <ptype>double</ptype>
than <ptype>float</ptype>, so they wanted to make it possible to use
<ptype>double</ptype> values too.)</p>

<p>To use real number coordinates, you have to use classes defined in the
package <code>java.awt.geom</code>.  Among the classes in this package are classes that
represent geometric shapes such as lines and rectangles.  For example,
the class <classname>Line2D</classname> represents a line whose endpoints
are given as real number coordinates.  The unfortunate thing is that
<classname>Line2D</classname> is an abstract class, which means that you can't
create objects of type <classname>Line2D</classname> directly.  However,
<classname>Line2D</classname> has two concrete subclasses that can be
used to create objects.  One subclass uses coordinates of type <ptype>float</ptype>,
and one uses coordinates of type <ptype>double</ptype>.  The most peculiar part is
that these subclasses are defined as static nested classes inside <classname>Line2D</classname>.
Their names are <classname>Line2D.Float</classname> and <classname>Line2D.Double</classname>.
This means that <classname>Line2D</classname> objects can be created, for example, with:</p>
   
<pre>Line2D line1 = new Line2D.Float( 0.17F, 1.3F, -2.7F, 5.21F );
Line2D line2 = new Line2D.Double( 0, 0, 1, 0);
Line2D line3 = new Line2D.Double( x1, y1, x2, y2 );</pre>
   
<np>where <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> are
any numeric variables.  In my own code, I generally use <classname>Line2D.Double</classname>
rather than <classname>Line2D.Float</classname>.</np>

<p>Other shape classes in <code>java.awt.geom</code> are similar.  The class that
represents rectangles is <classname>Rectangle2D</classname>.  To create a rectangle
object, you have to use either <classname>Rectangle2D.Float</classname> or
<classname>Rectangle2D.Double</classname>.  For example,</p>
   
<pre>Rectangle2D rect = new Rectangle2D.Double( -0.5, -0.5, 1.0, 1.0 );</pre>
   
<np>creates a rectangle with a corner at <code>(-0.5,-0.5)</code> and with
width and height both equal to&nbsp;1.  Other classes include <classname>Point2D</classname>,
which represents a single point; <classname>Ellipse2D</classname>, which represents
an oval; and <classname>Arc2D</classname>, which represents an arc of a circle.</np>
   
<p>If <code>g2</code> is of type <classname>Graphics2D</classname> and <code>shape</code>
is an object belonging to one of the 2D shape classes, then the command</p>
   
<pre>g2.draw(shape);</pre>
   
<np>draws the shape.  For a shape such as a rectangle or ellipse that has an interior,
only the outline is drawn.  To fill in the interior of such a shape, use</np>

<pre>g2.fill(shape)</pre>
   
<np>For example, to draw a line from <code>(x1,y1)</code> to <code>(x2,y2)</code>,
use</np>
   
<pre>g2.draw( new Line2D.Double(x1,y1,x2,y2) );</pre>
   
<np>and to draw a filled rectangle with a corner at <code>(3.5,7)</code>, with width 5
and height 3, use</np>
   
<pre>g2.fill( new Rectangle2D.Double(3.5, 7, 5, 3) );</pre>
   
<p>The package <code>java.awt.geom</code> also has a very nice class <classname>Path2D</classname>
that can be used to draw polygons and curves defined by any number of points.  See the
Java documentation if you want to find out how to use it. </p>

<p>This section has introduced you to many of the interesting features of <classname>Graphics2D</classname>,
but there is still a large part of the <classname>Graphics2D</classname> framework for you to explore.</p>
   
</subsection>
   
   
      
</section>

